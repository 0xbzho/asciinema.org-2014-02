[[0.095391,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],["                                                                ",{}]],"1":[["                                                                                ",{}]],"2":[["                                                                                ",{}]],"3":[["                                                                                ",{}]],"4":[["                                                                                ",{}]],"5":[["                                                                                ",{}]],"6":[["                                                                                ",{}]],"7":[["                                                                                ",{}]],"8":[["                                                                                ",{}]],"9":[["                                                                                ",{}]],"10":[["                                                                                ",{}]],"11":[["                                                                                ",{}]],"12":[["                                                                                ",{}]],"13":[["                                                                                ",{}]],"14":[["                                                                                ",{}]],"15":[["                                                                                ",{}]],"16":[["                                                                                ",{}]],"17":[["                                                                                ",{}]],"18":[["                                                                                ",{}]],"19":[["                                                                                ",{}]],"20":[["                                                                                ",{}]],"21":[["                                                                                ",{}]],"22":[["                                                                                ",{}]],"23":[["                                                                                ",{}]]},"cursor":{"x":17,"y":0,"visible":true}}],[4.89271,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" u                                                              ",{}]]},"cursor":{"x":18}}],[0.21595,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" un                                                             ",{}]]},"cursor":{"x":19}}],[0.175815,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" unm                                                            ",{}]]},"cursor":{"x":20}}],[0.048451,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" unma                                                           ",{}]]},"cursor":{"x":21}}],[0.160001,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" unmae                                                          ",{}]]},"cursor":{"x":22}}],[0.080135,{"cursor":{"x":23}}],[0.583934,{"cursor":{"x":22}}],[0.224368,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" unma                                                           ",{}]]},"cursor":{"x":21}}],[2.216945,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" unm                                                            ",{}]]},"cursor":{"x":20}}],[0.192462,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" un                                                             ",{}]]},"cursor":{"x":19}}],[0.175967,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" una                                                            ",{}]]},"cursor":{"x":20}}],[0.599732,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" unam                                                           ",{}]]},"cursor":{"x":21}}],[0.104555,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" uname                                                          ",{}]]},"cursor":{"x":22}}],[0.296104,{"cursor":{"x":23}}],[0.143517,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" uname -                                                        ",{}]]},"cursor":{"x":24}}],[0.056226,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" uname -a                                                       ",{}]]},"cursor":{"x":25}}],[0.649857,{"lines":{"1":[["Linux leon-vb 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i",{}]],"2":[["686 i686 GNU/Linux                                                              ",{}]]},"cursor":{"x":0,"y":3}}],[0.000237,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],["                                                                ",{}]]},"cursor":{"x":17}}],[1.991853,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" m                                                              ",{}]]},"cursor":{"x":18}}],[0.1115,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" ma                                                             ",{}]]},"cursor":{"x":19}}],[0.119577,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man                                                            ",{}]]},"cursor":{"x":20}}],[0.120642,{"cursor":{"x":21}}],[0.304347,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man c                                                          ",{}]]},"cursor":{"x":22}}],[1.368097,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man ca                                                         ",{}]]},"cursor":{"x":23}}],[0.15265,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man cal                                                        ",{}]]},"cursor":{"x":24}}],[0.159998,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man call                                                       ",{}]]},"cursor":{"x":25}}],[0.19187,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man callo                                                      ",{}]]},"cursor":{"x":26}}],[0.320088,{"lines":{"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man calloc                                                     ",{}]]},"cursor":{"x":27}}],[0.412007,{"cursor":{"x":0,"y":4}}],[0.045158,{"lines":{"0":[["                                                                                ",{}]],"1":[["                                                                                ",{}]],"2":[["                                                                                ",{}]],"3":[["                                                                                ",{}]]}}],[0.040791,{"lines":{"4":[["MALLOC(3)                  Linux Programmer's Manual                 MALLOC(3)  ",{}]]},"cursor":{"x":78}}],[0.007066999999999999,{"lines":{"0":[["MALLOC(3)                  Linux Programmer's Manual                 MALLOC(3)  ",{}]],"2":[["NAME",{"bold":true}],["                                                                            ",{}]],"3":[["       malloc, free, calloc, realloc - allocate and free dynamic memory         ",{}]],"4":[["                                                                                ",{}]],"5":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"6":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"8":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"9":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"10":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"11":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"13":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"14":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"15":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"16":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"17":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"19":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"20":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"21":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"22":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"23":[[" Manual page calloc(3) line 1 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]},"cursor":{"x":61,"y":23}}],[2.00884,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" uname -a                                                       ",{}]],"1":[["Linux leon-vb 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i",{}]],"2":[["686 i686 GNU/Linux                                                              ",{}]],"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man calloc                                                     ",{}]],"5":[["                                                                                ",{}]],"6":[["                                                                                ",{}]],"8":[["                                                                                ",{}]],"9":[["                                                                                ",{}]],"10":[["                                                                                ",{}]],"11":[["                                                                                ",{}]],"13":[["                                                                                ",{}]],"14":[["                                                                                ",{}]],"15":[["                                                                                ",{}]],"16":[["                                                                                ",{}]],"17":[["                                                                                ",{}]],"19":[["                                                                                ",{}]],"20":[["                                                                                ",{}]],"21":[["                                                                                ",{}]],"22":[["                                                                                ",{}]],"23":[["                                                                                ",{}]]},"cursor":{"x":0,"y":4}}],[0.000245,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],["                                                                ",{}]]},"cursor":{"x":17}}],[1.583848,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" m                                                              ",{}]]},"cursor":{"x":18}}],[0.088709,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" ma                                                             ",{}]]},"cursor":{"x":19}}],[0.11159,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man                                                            ",{}]]},"cursor":{"x":20}}],[0.144357,{"cursor":{"x":21}}],[0.383843,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man m                                                          ",{}]]},"cursor":{"x":22}}],[0.096549,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man ma                                                         ",{}]]},"cursor":{"x":23}}],[0.472303,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man mal                                                        ",{}]]},"cursor":{"x":24}}],[0.13566,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man mall                                                       ",{}]]},"cursor":{"x":25}}],[0.184232,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man mallo                                                      ",{}]]},"cursor":{"x":26}}],[0.112088,{"lines":{"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man malloc                                                     ",{}]]},"cursor":{"x":27}}],[0.245381,{"cursor":{"x":0,"y":5}}],[0.010296,{"lines":{"0":[["                                                                                ",{}]],"1":[["                                                                                ",{}]],"2":[["                                                                                ",{}]],"3":[["                                                                                ",{}]],"4":[["                                                                                ",{}]]}}],[0.047829,{"lines":{"5":[["MALLOC(3)                  Linux Programmer's Manual                 MALLOC(3)  ",{}]]},"cursor":{"x":78}}],[0.00618,{"lines":{"0":[["MALLOC(3)                  Linux Programmer's Manual                 MALLOC(3)  ",{}]],"2":[["NAME",{"bold":true}],["                                                                            ",{}]],"3":[["       malloc, free, calloc, realloc - allocate and free dynamic memory         ",{}]],"5":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"6":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"8":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"9":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"10":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"11":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"13":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"14":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"15":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"16":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"17":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"19":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"20":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"21":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"22":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"23":[[" Manual page malloc(3) line 1 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]},"cursor":{"x":61,"y":23}}],[1.826636,{"lines":{"0":[["                                                                                ",{}]],"1":[["NAME",{"bold":true}],["                                                                            ",{}]],"2":[["       malloc, free, calloc, realloc - allocate and free dynamic memory         ",{}]],"3":[["                                                                                ",{}]],"4":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"5":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"8":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"9":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"10":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"11":[["                                                                                ",{}]],"12":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"13":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"14":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"15":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"16":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"17":[["                                                                                ",{}]],"18":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"19":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"20":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"21":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 2 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]}}],[0.500256,{"lines":{"0":[["NAME",{"bold":true}],["                                                                            ",{}]],"1":[["       malloc, free, calloc, realloc - allocate and free dynamic memory         ",{}]],"2":[["                                                                                ",{}]],"3":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"4":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"7":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"8":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"9":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"10":[["                                                                                ",{}]],"11":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"12":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"13":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"14":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"15":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"16":[["                                                                                ",{}]],"17":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"18":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"19":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"20":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"21":[["                                                                                ",{}]],"22":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"23":[[" Manual page malloc(3) line 5 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]}}],[0.031429,{"lines":{"0":[["       malloc, free, calloc, realloc - allocate and free dynamic memory         ",{}]],"1":[["                                                                                ",{}]],"2":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"3":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"6":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"7":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"8":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"9":[["                                                                                ",{}]],"10":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"11":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"12":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"13":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"14":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"15":[["                                                                                ",{}]],"16":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"17":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"18":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"19":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"20":[["                                                                                ",{}]],"21":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"22":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"23":[[" Manual page malloc(3) line 6 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]}}],[0.029863,{"lines":{"0":[["                                                                                ",{}]],"1":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"2":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"5":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"6":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"7":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"8":[["                                                                                ",{}]],"9":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"10":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"11":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"12":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"13":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"14":[["                                                                                ",{}]],"15":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"16":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"17":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"18":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"19":[["                                                                                ",{}]],"20":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"21":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"22":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"23":[[" Manual page malloc(3) line 7 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]}}],[0.031046,{"lines":{"0":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"1":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"4":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"5":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"6":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"7":[["                                                                                ",{}]],"8":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"9":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"10":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"11":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"12":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"13":[["                                                                                ",{}]],"14":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"15":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"16":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"17":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"18":[["                                                                                ",{}]],"19":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"20":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"21":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"22":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"23":[[" Manual page malloc(3) line 8 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]}}],[0.030476,{"lines":{"0":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"3":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"4":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"5":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"6":[["                                                                                ",{}]],"7":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"8":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"9":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"10":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"11":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"12":[["                                                                                ",{}]],"13":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"14":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"15":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"16":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"17":[["                                                                                ",{}]],"18":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"19":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"20":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"21":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"22":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"23":[[" Manual page malloc(3) line 9 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]}}],[0.03187,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"2":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"3":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"4":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"5":[["                                                                                ",{}]],"6":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"7":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"8":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"9":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"10":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"11":[["                                                                                ",{}]],"12":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"13":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"14":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"15":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"16":[["                                                                                ",{}]],"17":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"18":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"19":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"20":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"21":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 10 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]},"cursor":{"x":62}}],[0.03021,{"lines":{"0":[["       ",{}],["void",{"bold":true}],[" ",{}],["*malloc(size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                               ",{}]],"1":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"2":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"3":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"4":[["                                                                                ",{}]],"5":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"6":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"7":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"8":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"9":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"10":[["                                                                                ",{}]],"11":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"12":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"13":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"14":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"15":[["                                                                                ",{}]],"16":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"17":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"18":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"19":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"20":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"21":[["                                                                                ",{}]],"22":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"23":[[" Manual page malloc(3) line 11 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031681,{"lines":{"0":[["       ",{}],["void",{"bold":true}],[" ",{}],["free(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[");",{"bold":true}],["                                                    ",{}]],"1":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"2":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"3":[["                                                                                ",{}]],"4":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"5":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"6":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"7":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"8":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"9":[["                                                                                ",{}]],"10":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"11":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"12":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"13":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"14":[["                                                                                ",{}]],"15":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"16":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"17":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"18":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"19":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"20":[["                                                                                ",{}]],"21":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"22":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"23":[[" Manual page malloc(3) line 12 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030402,{"lines":{"0":[["       ",{}],["void",{"bold":true}],[" ",{}],["*calloc(size_t",{"bold":true}],[" ",{}],["nmemb",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                 ",{}]],"1":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"2":[["                                                                                ",{}]],"3":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"4":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"5":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"6":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"7":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"8":[["                                                                                ",{}]],"9":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"10":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"11":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"12":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"13":[["                                                                                ",{}]],"14":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"15":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"16":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"17":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"18":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"19":[["                                                                                ",{}]],"20":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"21":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"22":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"23":[[" Manual page malloc(3) line 13 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030848,{"lines":{"0":[["       ",{}],["void",{"bold":true}],[" ",{}],["*realloc(void",{"bold":true}],[" ",{}],["*ptr",{"underline":true}],[",",{"bold":true}],[" ",{}],["size_t",{"bold":true}],[" ",{}],["size",{"underline":true}],[");",{"bold":true}],["                                   ",{}]],"1":[["                                                                                ",{}]],"2":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"3":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"4":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"5":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"6":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"7":[["                                                                                ",{}]],"8":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"9":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"10":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"11":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"12":[["                                                                                ",{}]],"13":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"14":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"15":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"16":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"17":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"18":[["                                                                                ",{}]],"19":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"20":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"21":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"22":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"23":[[" Manual page malloc(3) line 14 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030663,{"lines":{"0":[["                                                                                ",{}]],"1":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"2":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"3":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"4":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"5":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"6":[["                                                                                ",{}]],"7":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"8":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"9":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"10":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"11":[["                                                                                ",{}]],"12":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"13":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"14":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"15":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"16":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"17":[["                                                                                ",{}]],"18":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"19":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"20":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"21":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"22":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"23":[[" Manual page malloc(3) line 15 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030048,{"lines":{"0":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"1":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"2":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"3":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"4":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"5":[["                                                                                ",{}]],"6":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"7":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"8":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"9":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"10":[["                                                                                ",{}]],"11":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"12":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"13":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"14":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"15":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"16":[["                                                                                ",{}]],"17":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"18":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"19":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"20":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"21":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"22":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"23":[[" Manual page malloc(3) line 16 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030646,{"lines":{"0":[["       The ",{}],["malloc",{"bold":true}],["() function allocates ",{}],["size",{"underline":true}],[" bytes and returns a pointer to the  ",{}]],"1":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"2":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"3":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"4":[["                                                                                ",{}]],"5":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"6":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"7":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"8":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"9":[["                                                                                ",{}]],"10":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"11":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"12":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"13":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"14":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"15":[["                                                                                ",{}]],"16":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"17":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"18":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"19":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"20":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"21":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"22":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"23":[[" Manual page malloc(3) line 17 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030009,{"lines":{"0":[["       allocated memory.  ",{}],["The",{"underline":true}],[" ",{}],["memory",{"underline":true}],[" ",{}],["is",{"underline":true}],[" ",{}],["not",{"underline":true}],[" ",{}],["initialized",{"underline":true}],[".  If ",{}],["size",{"underline":true}],[" is  0,  then  ",{}]],"1":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"2":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"3":[["                                                                                ",{}]],"4":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"5":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"6":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"7":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"8":[["                                                                                ",{}]],"9":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"10":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"11":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"12":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"13":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"14":[["                                                                                ",{}]],"15":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"16":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"17":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"18":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"19":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"20":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"21":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"22":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"23":[[" Manual page malloc(3) line 18 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030314,{"lines":{"0":[["       ",{}],["malloc",{"bold":true}],["()  returns either NULL, or a unique pointer value that can later  ",{}]],"1":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"2":[["                                                                                ",{}]],"3":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"4":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"5":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"6":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"7":[["                                                                                ",{}]],"8":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"9":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"10":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"11":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"12":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"13":[["                                                                                ",{}]],"14":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"15":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"16":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"17":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"18":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"19":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"20":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"21":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"22":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"23":[[" Manual page malloc(3) line 19 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.029296,{"lines":{"0":[["       be successfully passed to ",{}],["free",{"bold":true}],["().                                        ",{}]],"1":[["                                                                                ",{}]],"2":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"3":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"4":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"5":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"6":[["                                                                                ",{}]],"7":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"8":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"9":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"10":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"11":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"12":[["                                                                                ",{}]],"13":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"14":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"15":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"16":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"17":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"18":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"19":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"20":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"21":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"22":[["       done.                                                                    ",{}]],"23":[[" Manual page malloc(3) line 20 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.029811,{"lines":{"0":[["                                                                                ",{}]],"1":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"2":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"3":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"4":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"5":[["                                                                                ",{}]],"6":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"7":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"8":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"9":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"10":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"11":[["                                                                                ",{}]],"12":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"13":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"14":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"15":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"16":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"17":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"18":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"19":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"20":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"21":[["       done.                                                                    ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 21 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030847,{"lines":{"0":[["       The ",{}],["free",{"bold":true}],["() function frees the memory space pointed  to  by  ",{}],["ptr",{"underline":true}],[",  which  ",{}]],"1":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"2":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"3":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"4":[["                                                                                ",{}]],"5":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"6":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"7":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"8":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"9":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"10":[["                                                                                ",{}]],"11":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"12":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"13":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"14":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"15":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"16":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"17":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"18":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"19":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"20":[["       done.                                                                    ",{}]],"21":[["                                                                                ",{}]],"22":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"23":[[" Manual page malloc(3) line 22 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031243,{"lines":{"0":[["       must  have  been  returned  by a previous call to ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["() or  ",{}]],"1":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"2":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"3":[["                                                                                ",{}]],"4":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"5":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"6":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"7":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"8":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"9":[["                                                                                ",{}]],"10":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"11":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"12":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"13":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"14":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"15":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"16":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"17":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"18":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"19":[["       done.                                                                    ",{}]],"20":[["                                                                                ",{}]],"21":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"22":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"23":[[" Manual page malloc(3) line 23 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030568,{"lines":{"0":[["       ",{}],["realloc",{"bold":true}],["().  Otherwise, or if ",{}],["free(ptr)",{"underline":true}],[" has already been called  before,  ",{}]],"1":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"2":[["                                                                                ",{}]],"3":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"4":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"5":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"6":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"7":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"8":[["                                                                                ",{}]],"9":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"10":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"11":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"12":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"13":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"14":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"15":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"16":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"17":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"18":[["       done.                                                                    ",{}]],"19":[["                                                                                ",{}]],"20":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"21":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"22":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"23":[[" Manual page malloc(3) line 24 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.029559,{"lines":{"0":[["       undefined behavior occurs.  If ",{}],["ptr",{"underline":true}],[" is NULL, no operation is performed.   ",{}]],"1":[["                                                                                ",{}]],"2":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"3":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"4":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"5":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"6":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"7":[["                                                                                ",{}]],"8":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"9":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"10":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"11":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"12":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"13":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"14":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"15":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"16":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"17":[["       done.                                                                    ",{}]],"18":[["                                                                                ",{}]],"19":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"20":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"21":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"22":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"23":[[" Manual page malloc(3) line 25 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030566,{"lines":{"0":[["                                                                                ",{}]],"1":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"2":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"3":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"4":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"5":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"6":[["                                                                                ",{}]],"7":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"8":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"9":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"10":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"11":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"12":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"13":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"14":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"15":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"16":[["       done.                                                                    ",{}]],"17":[["                                                                                ",{}]],"18":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"19":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"20":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"21":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"22":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"23":[[" Manual page malloc(3) line 26 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.03098,{"lines":{"0":[["       The  ",{}],["calloc",{"bold":true}],["()  function allocates memory for an array of ",{}],["nmemb",{"underline":true}],[" elements  ",{}]],"1":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"2":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"3":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"4":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"5":[["                                                                                ",{}]],"6":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"7":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"8":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"9":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"10":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"11":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"12":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"13":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"14":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"15":[["       done.                                                                    ",{}]],"16":[["                                                                                ",{}]],"17":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"18":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"19":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"20":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"21":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"22":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"23":[[" Manual page malloc(3) line 27 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030533,{"lines":{"0":[["       of ",{}],["size",{"underline":true}],[" bytes each and returns a pointer to the allocated memory.   The  ",{}]],"1":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"2":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"3":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"4":[["                                                                                ",{}]],"5":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"6":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"7":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"8":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"9":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"10":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"11":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"12":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"13":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"14":[["       done.                                                                    ",{}]],"15":[["                                                                                ",{}]],"16":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"17":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"18":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"19":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"20":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"21":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 28 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030003,{"lines":{"0":[["       memory  is  set  to zero.  If ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" is 0, then ",{}],["calloc",{"bold":true}],["() returns  ",{}]],"1":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"2":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"3":[["                                                                                ",{}]],"4":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"5":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"6":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"7":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"8":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"9":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"10":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"11":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"12":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"13":[["       done.                                                                    ",{}]],"14":[["                                                                                ",{}]],"15":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"16":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"17":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"18":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"19":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"20":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"21":[["                                                                                ",{}]],"22":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"23":[[" Manual page malloc(3) line 29 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030219,{"lines":{"0":[["       either NULL, or a unique pointer value that can later  be  successfully  ",{}]],"1":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"2":[["                                                                                ",{}]],"3":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"4":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"5":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"6":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"7":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"8":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"9":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"10":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"11":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"12":[["       done.                                                                    ",{}]],"13":[["                                                                                ",{}]],"14":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"15":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"16":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"17":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"18":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"19":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"20":[["                                                                                ",{}]],"21":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 30 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031335,{"lines":{"0":[["       passed to ",{}],["free",{"bold":true}],["().                                                        ",{}]],"1":[["                                                                                ",{}]],"2":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"3":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"4":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"5":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"6":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"7":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"8":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"9":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"10":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"11":[["       done.                                                                    ",{}]],"12":[["                                                                                ",{}]],"13":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"14":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"15":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"16":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"17":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"18":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"19":[["                                                                                ",{}]],"20":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"21":[["                                                                                ",{}]],"22":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"23":[[" Manual page malloc(3) line 31 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030728,{"lines":{"0":[["                                                                                ",{}]],"1":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"2":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"3":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"4":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"5":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"6":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"7":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"8":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"9":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"10":[["       done.                                                                    ",{}]],"11":[["                                                                                ",{}]],"12":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"13":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"14":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"15":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"16":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"17":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"18":[["                                                                                ",{}]],"19":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"20":[["                                                                                ",{}]],"21":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"22":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"23":[[" Manual page malloc(3) line 32 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.029565,{"lines":{"0":[["       The  ",{}],["realloc",{"bold":true}],["() function changes the size of the memory block pointed to  ",{}]],"1":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"2":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"3":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"4":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"5":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"6":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"7":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"8":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"9":[["       done.                                                                    ",{}]],"10":[["                                                                                ",{}]],"11":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"12":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"13":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"14":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"15":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"16":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"17":[["                                                                                ",{}]],"18":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"19":[["                                                                                ",{}]],"20":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"21":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"22":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"23":[[" Manual page malloc(3) line 33 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030405,{"lines":{"0":[["       by ",{}],["ptr",{"underline":true}],[" to ",{}],["size",{"underline":true}],[" bytes.  The contents will be unchanged in the range from  ",{}]],"1":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"2":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"3":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"4":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"5":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"6":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"7":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"8":[["       done.                                                                    ",{}]],"9":[["                                                                                ",{}]],"10":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"11":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"12":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"13":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"14":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"15":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"16":[["                                                                                ",{}]],"17":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"18":[["                                                                                ",{}]],"19":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"20":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"21":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"22":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"23":[[" Manual page malloc(3) line 34 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030073,{"lines":{"0":[["       the start of the region up to the minimum of the old and new sizes.  If  ",{}]],"1":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"2":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"3":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"4":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"5":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"6":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"7":[["       done.                                                                    ",{}]],"8":[["                                                                                ",{}]],"9":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"10":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"11":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"12":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"13":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"14":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"15":[["                                                                                ",{}]],"16":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"17":[["                                                                                ",{}]],"18":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"19":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"20":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"21":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"22":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"23":[[" Manual page malloc(3) line 35 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030177,{"lines":{"0":[["       the new size is larger than the old size, the added memory will ",{}],["not",{"underline":true}],["  be  ",{}]],"1":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"2":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"3":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"4":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"5":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"6":[["       done.                                                                    ",{}]],"7":[["                                                                                ",{}]],"8":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"9":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"10":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"11":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"12":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"13":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"14":[["                                                                                ",{}]],"15":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"16":[["                                                                                ",{}]],"17":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"18":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"19":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"20":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"21":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"22":[["       or moved.                                                                ",{}]],"23":[[" Manual page malloc(3) line 36 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030792,{"lines":{"0":[["       initialized.   If  ",{}],["ptr",{"underline":true}],["  is  NULL,  then  the call is equivalent to ",{}],["mal‐",{"underline":true}],["  ",{}]],"1":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"2":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"3":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"4":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"5":[["       done.                                                                    ",{}]],"6":[["                                                                                ",{}]],"7":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"8":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"9":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"10":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"11":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"12":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"13":[["                                                                                ",{}]],"14":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"15":[["                                                                                ",{}]],"16":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"17":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"18":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"19":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"20":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"21":[["       or moved.                                                                ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 37 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030733,{"lines":{"0":[["       ",{}],["loc(size)",{"underline":true}],[", for all values of ",{}],["size",{"underline":true}],["; if ",{}],["size",{"underline":true}],[" is equal to zero, and ",{}],["ptr",{"underline":true}],[" is  ",{}]],"1":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"2":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"3":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"4":[["       done.                                                                    ",{}]],"5":[["                                                                                ",{}]],"6":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"7":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"8":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"9":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"10":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"11":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"12":[["                                                                                ",{}]],"13":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"14":[["                                                                                ",{}]],"15":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"16":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"17":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"18":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"19":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"20":[["       or moved.                                                                ",{}]],"21":[["                                                                                ",{}]],"22":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"23":[[" Manual page malloc(3) line 38 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030205,{"lines":{"0":[["       not  NULL,  then  the  call  is equivalent to ",{}],["free(ptr)",{"underline":true}],[".  Unless ",{}],["ptr",{"underline":true}],[" is  ",{}]],"1":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"2":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"3":[["       done.                                                                    ",{}]],"4":[["                                                                                ",{}]],"5":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"6":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"7":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"8":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"9":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"10":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"11":[["                                                                                ",{}]],"12":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"13":[["                                                                                ",{}]],"14":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"15":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"16":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"17":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"18":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"19":[["       or moved.                                                                ",{}]],"20":[["                                                                                ",{}]],"21":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"22":[["       C89, C99.                                                                ",{}]],"23":[[" Manual page malloc(3) line 39 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.03051,{"lines":{"0":[["       NULL, it must have been returned by an earlier call to  ",{}],["malloc",{"bold":true}],["(),  ",{}],["cal‐",{"bold":true}],["  ",{}]],"1":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"2":[["       done.                                                                    ",{}]],"3":[["                                                                                ",{}]],"4":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"5":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"6":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"7":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"8":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"9":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"10":[["                                                                                ",{}]],"11":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"12":[["                                                                                ",{}]],"13":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"14":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"15":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"16":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"17":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"18":[["       or moved.                                                                ",{}]],"19":[["                                                                                ",{}]],"20":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"21":[["       C89, C99.                                                                ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 40 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030884,{"lines":{"0":[["       ",{}],["loc",{"bold":true}],["()  or  ",{}],["realloc",{"bold":true}],["().  If the area pointed to was moved, a ",{}],["free(ptr)",{"underline":true}],[" is  ",{}]],"1":[["       done.                                                                    ",{}]],"2":[["                                                                                ",{}]],"3":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"4":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"5":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"6":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"7":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"8":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"9":[["                                                                                ",{}]],"10":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"11":[["                                                                                ",{}]],"12":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"13":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"14":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"15":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"16":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"17":[["       or moved.                                                                ",{}]],"18":[["                                                                                ",{}]],"19":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"20":[["       C89, C99.                                                                ",{}]],"21":[["                                                                                ",{}]],"22":[["NOTES",{"bold":true}],["                                                                           ",{}]],"23":[[" Manual page malloc(3) line 41 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030828,{"lines":{"0":[["       done.                                                                    ",{}]],"1":[["                                                                                ",{}]],"2":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"3":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"4":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"5":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"6":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"7":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"8":[["                                                                                ",{}]],"9":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"10":[["                                                                                ",{}]],"11":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"12":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"13":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"14":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"15":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"16":[["       or moved.                                                                ",{}]],"17":[["                                                                                ",{}]],"18":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"19":[["       C89, C99.                                                                ",{}]],"20":[["                                                                                ",{}]],"21":[["NOTES",{"bold":true}],["                                                                           ",{}]],"22":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"23":[[" Manual page malloc(3) line 42 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031266,{"lines":{"0":[["                                                                                ",{}]],"1":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"2":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"3":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"4":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"5":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"6":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"7":[["                                                                                ",{}]],"8":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"9":[["                                                                                ",{}]],"10":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"11":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"12":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"13":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"14":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"15":[["       or moved.                                                                ",{}]],"16":[["                                                                                ",{}]],"17":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"18":[["       C89, C99.                                                                ",{}]],"19":[["                                                                                ",{}]],"20":[["NOTES",{"bold":true}],["                                                                           ",{}]],"21":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"22":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"23":[[" Manual page malloc(3) line 43 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.028891,{"lines":{"0":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"1":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"2":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"3":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"4":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"5":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"6":[["                                                                                ",{}]],"7":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"8":[["                                                                                ",{}]],"9":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"10":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"11":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"12":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"13":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"14":[["       or moved.                                                                ",{}]],"15":[["                                                                                ",{}]],"16":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"17":[["       C89, C99.                                                                ",{}]],"18":[["                                                                                ",{}]],"19":[["NOTES",{"bold":true}],["                                                                           ",{}]],"20":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"21":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"22":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"23":[[" Manual page malloc(3) line 44 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.03044,{"lines":{"0":[["       The ",{}],["malloc",{"bold":true}],["() and ",{}],["calloc",{"bold":true}],["() functions return a pointer to  the  allocated  ",{}]],"1":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"2":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"3":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"4":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"5":[["                                                                                ",{}]],"6":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"7":[["                                                                                ",{}]],"8":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"9":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"10":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"11":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"12":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"13":[["       or moved.                                                                ",{}]],"14":[["                                                                                ",{}]],"15":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"16":[["       C89, C99.                                                                ",{}]],"17":[["                                                                                ",{}]],"18":[["NOTES",{"bold":true}],["                                                                           ",{}]],"19":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"20":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"21":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"22":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"23":[[" Manual page malloc(3) line 45 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030004,{"lines":{"0":[["       memory  that  is  suitably aligned for any kind of variable.  On error,  ",{}]],"1":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"2":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"3":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"4":[["                                                                                ",{}]],"5":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"6":[["                                                                                ",{}]],"7":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"8":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"9":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"10":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"11":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"12":[["       or moved.                                                                ",{}]],"13":[["                                                                                ",{}]],"14":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"15":[["       C89, C99.                                                                ",{}]],"16":[["                                                                                ",{}]],"17":[["NOTES",{"bold":true}],["                                                                           ",{}]],"18":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"19":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"20":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"21":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"22":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"23":[[" Manual page malloc(3) line 46 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030062,{"lines":{"0":[["       these functions return NULL.  NULL may also be returned by a successful  ",{}]],"1":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"2":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"3":[["                                                                                ",{}]],"4":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"5":[["                                                                                ",{}]],"6":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"7":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"8":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"9":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"10":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"11":[["       or moved.                                                                ",{}]],"12":[["                                                                                ",{}]],"13":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"14":[["       C89, C99.                                                                ",{}]],"15":[["                                                                                ",{}]],"16":[["NOTES",{"bold":true}],["                                                                           ",{}]],"17":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"18":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"19":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"20":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"21":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"22":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"23":[[" Manual page malloc(3) line 47 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030493,{"lines":{"0":[["       call  to  ",{}],["malloc",{"bold":true}],["() with a ",{}],["size",{"underline":true}],[" of zero, or by a successful call to ",{}],["cal‐",{"bold":true}],["  ",{}]],"1":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"2":[["                                                                                ",{}]],"3":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"4":[["                                                                                ",{}]],"5":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"6":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"7":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"8":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"9":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"10":[["       or moved.                                                                ",{}]],"11":[["                                                                                ",{}]],"12":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"13":[["       C89, C99.                                                                ",{}]],"14":[["                                                                                ",{}]],"15":[["NOTES",{"bold":true}],["                                                                           ",{}]],"16":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"17":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"18":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"19":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"20":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"21":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"22":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"23":[[" Manual page malloc(3) line 48 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031068,{"lines":{"0":[["       ",{}],["loc",{"bold":true}],["() with ",{}],["nmemb",{"underline":true}],[" or ",{}],["size",{"underline":true}],[" equal to zero.                                  ",{}]],"1":[["                                                                                ",{}]],"2":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"3":[["                                                                                ",{}]],"4":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"5":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"6":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"7":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"8":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"9":[["       or moved.                                                                ",{}]],"10":[["                                                                                ",{}]],"11":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"12":[["       C89, C99.                                                                ",{}]],"13":[["                                                                                ",{}]],"14":[["NOTES",{"bold":true}],["                                                                           ",{}]],"15":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"16":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"17":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"18":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"19":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"20":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"21":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 49 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030328,{"lines":{"0":[["                                                                                ",{}]],"1":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"2":[["                                                                                ",{}]],"3":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"4":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"5":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"6":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"7":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"8":[["       or moved.                                                                ",{}]],"9":[["                                                                                ",{}]],"10":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"11":[["       C89, C99.                                                                ",{}]],"12":[["                                                                                ",{}]],"13":[["NOTES",{"bold":true}],["                                                                           ",{}]],"14":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"15":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"16":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"17":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"18":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"19":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"20":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"21":[["                                                                                ",{}]],"22":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"23":[[" Manual page malloc(3) line 50 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031165,{"lines":{"0":[["       The ",{}],["free",{"bold":true}],["() function returns no value.                                    ",{}]],"1":[["                                                                                ",{}]],"2":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"3":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"4":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"5":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"6":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"7":[["       or moved.                                                                ",{}]],"8":[["                                                                                ",{}]],"9":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"10":[["       C89, C99.                                                                ",{}]],"11":[["                                                                                ",{}]],"12":[["NOTES",{"bold":true}],["                                                                           ",{}]],"13":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"14":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"15":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"16":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"17":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"18":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"19":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"20":[["                                                                                ",{}]],"21":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"22":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"23":[[" Manual page malloc(3) line 51 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030184,{"lines":{"0":[["                                                                                ",{}]],"1":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"2":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"3":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"4":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"5":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"6":[["       or moved.                                                                ",{}]],"7":[["                                                                                ",{}]],"8":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"9":[["       C89, C99.                                                                ",{}]],"10":[["                                                                                ",{}]],"11":[["NOTES",{"bold":true}],["                                                                           ",{}]],"12":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"13":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"14":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"15":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"16":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"17":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"18":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"19":[["                                                                                ",{}]],"20":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"21":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"22":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"23":[[" Manual page malloc(3) line 52 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030105,{"lines":{"0":[["       The ",{}],["realloc",{"bold":true}],["() function returns a pointer to the newly allocated memory,  ",{}]],"1":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"2":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"3":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"4":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"5":[["       or moved.                                                                ",{}]],"6":[["                                                                                ",{}]],"7":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"8":[["       C89, C99.                                                                ",{}]],"9":[["                                                                                ",{}]],"10":[["NOTES",{"bold":true}],["                                                                           ",{}]],"11":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"12":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"13":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"14":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"15":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"16":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"17":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"18":[["                                                                                ",{}]],"19":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"20":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"21":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"22":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"23":[[" Manual page malloc(3) line 53 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030094,{"lines":{"0":[["       which is suitably aligned for any kind of variable and may be different  ",{}]],"1":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"2":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"3":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"4":[["       or moved.                                                                ",{}]],"5":[["                                                                                ",{}]],"6":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"7":[["       C89, C99.                                                                ",{}]],"8":[["                                                                                ",{}]],"9":[["NOTES",{"bold":true}],["                                                                           ",{}]],"10":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"11":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"12":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"13":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"14":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"15":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"16":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"17":[["                                                                                ",{}]],"18":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"19":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"20":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"21":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"22":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"23":[[" Manual page malloc(3) line 54 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031073,{"lines":{"0":[["       from ",{}],["ptr",{"underline":true}],[", or NULL if the request fails.  If ",{}],["size",{"underline":true}],[" was equal to 0, either  ",{}]],"1":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"2":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"3":[["       or moved.                                                                ",{}]],"4":[["                                                                                ",{}]],"5":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"6":[["       C89, C99.                                                                ",{}]],"7":[["                                                                                ",{}]],"8":[["NOTES",{"bold":true}],["                                                                           ",{}]],"9":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"10":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"11":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"12":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"13":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"14":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"15":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"16":[["                                                                                ",{}]],"17":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"18":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"19":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"20":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"21":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"22":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"23":[[" Manual page malloc(3) line 55 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031324,{"lines":{"0":[["       NULL  or  a  pointer  suitable  to be passed to ",{}],["free",{"bold":true}],["() is returned.  If  ",{}]],"1":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"2":[["       or moved.                                                                ",{}]],"3":[["                                                                                ",{}]],"4":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"5":[["       C89, C99.                                                                ",{}]],"6":[["                                                                                ",{}]],"7":[["NOTES",{"bold":true}],["                                                                           ",{}]],"8":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"9":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"10":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"11":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"12":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"13":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"14":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"15":[["                                                                                ",{}]],"16":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"17":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"18":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"19":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"20":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"21":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"22":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"23":[[" Manual page malloc(3) line 56 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.032184,{"lines":{"0":[["       ",{}],["realloc",{"bold":true}],["() fails the original block is left untouched; it is  not  freed  ",{}]],"1":[["       or moved.                                                                ",{}]],"2":[["                                                                                ",{}]],"3":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"4":[["       C89, C99.                                                                ",{}]],"5":[["                                                                                ",{}]],"6":[["NOTES",{"bold":true}],["                                                                           ",{}]],"7":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"8":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"9":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"10":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"11":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"12":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"13":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"14":[["                                                                                ",{}]],"15":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"16":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"17":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"18":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"19":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"20":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"21":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 57 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031594,{"lines":{"0":[["       or moved.                                                                ",{}]],"1":[["                                                                                ",{}]],"2":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"3":[["       C89, C99.                                                                ",{}]],"4":[["                                                                                ",{}]],"5":[["NOTES",{"bold":true}],["                                                                           ",{}]],"6":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"7":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"8":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"9":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"10":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"11":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"12":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"13":[["                                                                                ",{}]],"14":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"15":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"16":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"17":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"18":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"19":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"20":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"21":[["                                                                                ",{}]],"22":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"23":[[" Manual page malloc(3) line 58 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.03139,{"lines":{"0":[["                                                                                ",{}]],"1":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"2":[["       C89, C99.                                                                ",{}]],"3":[["                                                                                ",{}]],"4":[["NOTES",{"bold":true}],["                                                                           ",{}]],"5":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"6":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"7":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"8":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"9":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"10":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"11":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"12":[["                                                                                ",{}]],"13":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"14":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"15":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"16":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"17":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"18":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"19":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"20":[["                                                                                ",{}]],"21":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"22":[["       internally to protect the memory-management data structures employed by  ",{}]],"23":[[" Manual page malloc(3) line 59 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030066,{"lines":{"0":[["CONFORMING",{"bold":true}],[" ",{}],["TO",{"bold":true}],["                                                                   ",{}]],"1":[["       C89, C99.                                                                ",{}]],"2":[["                                                                                ",{}]],"3":[["NOTES",{"bold":true}],["                                                                           ",{}]],"4":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"5":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"6":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"7":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"8":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"9":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"10":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"11":[["                                                                                ",{}]],"12":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"13":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"14":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"15":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"16":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"17":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"18":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"19":[["                                                                                ",{}]],"20":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"21":[["       internally to protect the memory-management data structures employed by  ",{}]],"22":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"23":[[" Manual page malloc(3) line 60 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031011,{"lines":{"0":[["       C89, C99.                                                                ",{}]],"1":[["                                                                                ",{}]],"2":[["NOTES",{"bold":true}],["                                                                           ",{}]],"3":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"4":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"5":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"6":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"7":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"8":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"9":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"10":[["                                                                                ",{}]],"11":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"12":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"13":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"14":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"15":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"16":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"17":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"18":[["                                                                                ",{}]],"19":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"20":[["       internally to protect the memory-management data structures employed by  ",{}]],"21":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"22":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"23":[[" Manual page malloc(3) line 61 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.03294,{"lines":{"0":[["                                                                                ",{}]],"1":[["NOTES",{"bold":true}],["                                                                           ",{}]],"2":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"3":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"4":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"5":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"6":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"7":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"8":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"9":[["                                                                                ",{}]],"10":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"11":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"12":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"13":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"14":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"15":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"16":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"17":[["                                                                                ",{}]],"18":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"19":[["       internally to protect the memory-management data structures employed by  ",{}]],"20":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"21":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"22":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"23":[[" Manual page malloc(3) line 62 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.029282,{"lines":{"0":[["NOTES",{"bold":true}],["                                                                           ",{}]],"1":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"2":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"3":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"4":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"5":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"6":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"7":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"8":[["                                                                                ",{}]],"9":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"10":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"11":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"12":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"13":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"14":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"15":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"16":[["                                                                                ",{}]],"17":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"18":[["       internally to protect the memory-management data structures employed by  ",{}]],"19":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"20":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"21":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"22":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"23":[[" Manual page malloc(3) line 63 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030984,{"lines":{"0":[["       By  default,  Linux  follows  an optimistic memory allocation strategy.  ",{}]],"1":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"2":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"3":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"4":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"5":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"6":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"7":[["                                                                                ",{}]],"8":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"9":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"10":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"11":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"12":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"13":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"14":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"15":[["                                                                                ",{}]],"16":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"17":[["       internally to protect the memory-management data structures employed by  ",{}]],"18":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"19":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"20":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"21":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"22":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"23":[[" Manual page malloc(3) line 64 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031887,{"lines":{"0":[["       This means that when ",{}],["malloc",{"bold":true}],["() returns non-NULL there  is  no  guarantee  ",{}]],"1":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"2":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"3":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"4":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"5":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"6":[["                                                                                ",{}]],"7":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"8":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"9":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"10":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"11":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"12":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"13":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"14":[["                                                                                ",{}]],"15":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"16":[["       internally to protect the memory-management data structures employed by  ",{}]],"17":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"18":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"19":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"20":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"21":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"22":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"23":[[" Manual page malloc(3) line 65 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030871,{"lines":{"0":[["       that  the  memory  really  is available.  In case it turns out that the  ",{}]],"1":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"2":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"3":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"4":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"5":[["                                                                                ",{}]],"6":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"7":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"8":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"9":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"10":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"11":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"12":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"13":[["                                                                                ",{}]],"14":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"15":[["       internally to protect the memory-management data structures employed by  ",{}]],"16":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"17":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"18":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"19":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"20":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"21":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"22":[["       and managed with its own mutexes.                                        ",{}]],"23":[[" Manual page malloc(3) line 66 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030481,{"lines":{"0":[["       system is out of memory, one or more processes will be  killed  by  the  ",{}]],"1":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"2":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"3":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"4":[["                                                                                ",{}]],"5":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"6":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"7":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"8":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"9":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"10":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"11":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"12":[["                                                                                ",{}]],"13":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"14":[["       internally to protect the memory-management data structures employed by  ",{}]],"15":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"16":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"17":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"18":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"19":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"20":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"21":[["       and managed with its own mutexes.                                        ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 67 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030796,{"lines":{"0":[["       OOM   killer.    For   more   information,   see   the  description  of  ",{}]],"1":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"2":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"3":[["                                                                                ",{}]],"4":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"5":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"6":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"7":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"8":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"9":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"10":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"11":[["                                                                                ",{}]],"12":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"13":[["       internally to protect the memory-management data structures employed by  ",{}]],"14":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"15":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"16":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"17":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"18":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"19":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"20":[["       and managed with its own mutexes.                                        ",{}]],"21":[["                                                                                ",{}]],"22":[["       The  UNIX 98 standard requires ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), and ",{}],["realloc",{"bold":true}],["() to set  ",{}]],"23":[[" Manual page malloc(3) line 68 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031897,{"lines":{"0":[["       ",{}],["/proc/sys/vm/overcommit_memory",{"underline":true}],[" and ",{}],["/proc/sys/vm/oom_adj",{"underline":true}],[" in ",{}],["proc",{"bold":true}],["(5), and  ",{}]],"1":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"2":[["                                                                                ",{}]],"3":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"4":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"5":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"6":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"7":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"8":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"9":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"10":[["                                                                                ",{}]],"11":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"12":[["       internally to protect the memory-management data structures employed by  ",{}]],"13":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"14":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"15":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"16":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"17":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"18":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"19":[["       and managed with its own mutexes.                                        ",{}]],"20":[["                                                                                ",{}]],"21":[["       The  UNIX 98 standard requires ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), and ",{}],["realloc",{"bold":true}],["() to set  ",{}]],"22":[["       ",{}],["errno",{"underline":true}],[" to ",{}],["ENOMEM",{"bold":true}],[" upon failure.  Glibc assumes that this is done (and the  ",{}]],"23":[[" Manual page malloc(3) line 69 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031785,{"lines":{"0":[["       the Linux kernel source file ",{}],["Documentation/vm/overcommit-accounting",{"underline":true}],[".     ",{}]],"1":[["                                                                                ",{}]],"2":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"3":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"4":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"5":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"6":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"7":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"8":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"9":[["                                                                                ",{}]],"10":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"11":[["       internally to protect the memory-management data structures employed by  ",{}]],"12":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"13":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"14":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"15":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"16":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"17":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"18":[["       and managed with its own mutexes.                                        ",{}]],"19":[["                                                                                ",{}]],"20":[["       The  UNIX 98 standard requires ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), and ",{}],["realloc",{"bold":true}],["() to set  ",{}]],"21":[["       ",{}],["errno",{"underline":true}],[" to ",{}],["ENOMEM",{"bold":true}],[" upon failure.  Glibc assumes that this is done (and the  ",{}]],"22":[["       glibc  versions of these routines do this); if you use a private malloc  ",{}]],"23":[[" Manual page malloc(3) line 70 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030684,{"lines":{"0":[["                                                                                ",{}]],"1":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"2":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"3":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"4":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"5":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"6":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"7":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"8":[["                                                                                ",{}]],"9":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"10":[["       internally to protect the memory-management data structures employed by  ",{}]],"11":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"12":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"13":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"14":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"15":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"16":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"17":[["       and managed with its own mutexes.                                        ",{}]],"18":[["                                                                                ",{}]],"19":[["       The  UNIX 98 standard requires ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), and ",{}],["realloc",{"bold":true}],["() to set  ",{}]],"20":[["       ",{}],["errno",{"underline":true}],[" to ",{}],["ENOMEM",{"bold":true}],[" upon failure.  Glibc assumes that this is done (and the  ",{}]],"21":[["       glibc  versions of these routines do this); if you use a private malloc  ",{}]],"22":[["       implementation that does not set ",{}],["errno",{"underline":true}],[", then certain  library  routines  ",{}]],"23":[[" Manual page malloc(3) line 71 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.032633,{"lines":{"0":[["       Normally, ",{}],["malloc",{"bold":true}],["() allocates memory from the heap, and adjusts the size  ",{}]],"1":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"2":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"3":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"4":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"5":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"6":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"7":[["                                                                                ",{}]],"8":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"9":[["       internally to protect the memory-management data structures employed by  ",{}]],"10":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"11":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"12":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"13":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"14":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"15":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"16":[["       and managed with its own mutexes.                                        ",{}]],"17":[["                                                                                ",{}]],"18":[["       The  UNIX 98 standard requires ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), and ",{}],["realloc",{"bold":true}],["() to set  ",{}]],"19":[["       ",{}],["errno",{"underline":true}],[" to ",{}],["ENOMEM",{"bold":true}],[" upon failure.  Glibc assumes that this is done (and the  ",{}]],"20":[["       glibc  versions of these routines do this); if you use a private malloc  ",{}]],"21":[["       implementation that does not set ",{}],["errno",{"underline":true}],[", then certain  library  routines  ",{}]],"22":[["       may fail without having a reason in ",{}],["errno",{"underline":true}],[".                               ",{}]],"23":[[" Manual page malloc(3) line 72 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030867,{"lines":{"0":[["       of the heap as required, using ",{}],["sbrk",{"bold":true}],["(2).  When allocating blocks of mem‐  ",{}]],"1":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"2":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"3":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"4":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"5":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"6":[["                                                                                ",{}]],"7":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"8":[["       internally to protect the memory-management data structures employed by  ",{}]],"9":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"10":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"11":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"12":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"13":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"14":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"15":[["       and managed with its own mutexes.                                        ",{}]],"16":[["                                                                                ",{}]],"17":[["       The  UNIX 98 standard requires ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), and ",{}],["realloc",{"bold":true}],["() to set  ",{}]],"18":[["       ",{}],["errno",{"underline":true}],[" to ",{}],["ENOMEM",{"bold":true}],[" upon failure.  Glibc assumes that this is done (and the  ",{}]],"19":[["       glibc  versions of these routines do this); if you use a private malloc  ",{}]],"20":[["       implementation that does not set ",{}],["errno",{"underline":true}],[", then certain  library  routines  ",{}]],"21":[["       may fail without having a reason in ",{}],["errno",{"underline":true}],[".                               ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page malloc(3) line 73 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031128,{"lines":{"0":[["       ory larger than ",{}],["MMAP_THRESHOLD",{"bold":true}],[" bytes, the glibc ",{}],["malloc",{"bold":true}],["() implementation  ",{}]],"1":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"2":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"3":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"4":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"5":[["                                                                                ",{}]],"6":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"7":[["       internally to protect the memory-management data structures employed by  ",{}]],"8":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"9":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"10":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"11":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"12":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"13":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"14":[["       and managed with its own mutexes.                                        ",{}]],"15":[["                                                                                ",{}]],"16":[["       The  UNIX 98 standard requires ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), and ",{}],["realloc",{"bold":true}],["() to set  ",{}]],"17":[["       ",{}],["errno",{"underline":true}],[" to ",{}],["ENOMEM",{"bold":true}],[" upon failure.  Glibc assumes that this is done (and the  ",{}]],"18":[["       glibc  versions of these routines do this); if you use a private malloc  ",{}]],"19":[["       implementation that does not set ",{}],["errno",{"underline":true}],[", then certain  library  routines  ",{}]],"20":[["       may fail without having a reason in ",{}],["errno",{"underline":true}],[".                               ",{}]],"21":[["                                                                                ",{}]],"22":[["       Crashes  in  ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), ",{}],["realloc",{"bold":true}],["(), or ",{}],["free",{"bold":true}],["() are almost always  ",{}]],"23":[[" Manual page malloc(3) line 74 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.029848,{"lines":{"0":[["       allocates the memory as a  private  anonymous  mapping  using  ",{}],["mmap",{"bold":true}],["(2).  ",{}]],"1":[["       ",{}],["MMAP_THRESHOLD",{"bold":true}],["  is  128  kB  by  default,  but is adjustable using ",{}],["mal‐",{"bold":true}],["  ",{}]],"2":[["       ",{}],["lopt",{"bold":true}],["(3).  Allocations performed using ",{}],["mmap",{"bold":true}],["(2)  are  unaffected  by  the  ",{}]],"3":[["       ",{}],["RLIMIT_DATA",{"bold":true}],[" resource limit (see ",{}],["getrlimit",{"bold":true}],["(2)).                           ",{}]],"4":[["                                                                                ",{}]],"5":[["       To  avoid  corruption  in  multithreaded applications, mutexes are used  ",{}]],"6":[["       internally to protect the memory-management data structures employed by  ",{}]],"7":[["       these  functions.   In  a  multithreaded  application  in which threads  ",{}]],"8":[["       simultaneously allocate and free memory, there could be contention  for  ",{}]],"9":[["       these  mutexes.   To scalably handle memory allocation in multithreaded  ",{}]],"10":[["       applications, glibc creates  additional  ",{}],["memory",{"underline":true}],["  ",{}],["allocation",{"underline":true}],["  ",{}],["arenas",{"underline":true}],["  if  ",{}]],"11":[["       mutex  contention  is detected.  Each arena is a large region of memory  ",{}]],"12":[["       that is internally allocated by the system (using ",{}],["brk",{"bold":true}],["(2)  or  ",{}],["mmap",{"bold":true}],["(2)),  ",{}]],"13":[["       and managed with its own mutexes.                                        ",{}]],"14":[["                                                                                ",{}]],"15":[["       The  UNIX 98 standard requires ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), and ",{}],["realloc",{"bold":true}],["() to set  ",{}]],"16":[["       ",{}],["errno",{"underline":true}],[" to ",{}],["ENOMEM",{"bold":true}],[" upon failure.  Glibc assumes that this is done (and the  ",{}]],"17":[["       glibc  versions of these routines do this); if you use a private malloc  ",{}]],"18":[["       implementation that does not set ",{}],["errno",{"underline":true}],[", then certain  library  routines  ",{}]],"19":[["       may fail without having a reason in ",{}],["errno",{"underline":true}],[".                               ",{}]],"20":[["                                                                                ",{}]],"21":[["       Crashes  in  ",{}],["malloc",{"bold":true}],["(), ",{}],["calloc",{"bold":true}],["(), ",{}],["realloc",{"bold":true}],["(), or ",{}],["free",{"bold":true}],["() are almost always  ",{}]],"22":[["       related to heap corruption, such as overflowing an allocated  chunk  or  ",{}]],"23":[[" Manual page malloc(3) line 75 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.162128,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" uname -a                                                       ",{}]],"1":[["Linux leon-vb 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i",{}]],"2":[["686 i686 GNU/Linux                                                              ",{}]],"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man calloc                                                     ",{}]],"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man malloc                                                     ",{}]],"5":[["                                                                                ",{}]],"6":[["                                                                                ",{}]],"7":[["                                                                                ",{}]],"8":[["                                                                                ",{}]],"9":[["                                                                                ",{}]],"10":[["                                                                                ",{}]],"11":[["                                                                                ",{}]],"12":[["                                                                                ",{}]],"13":[["                                                                                ",{}]],"15":[["                                                                                ",{}]],"16":[["                                                                                ",{}]],"17":[["                                                                                ",{}]],"18":[["                                                                                ",{}]],"19":[["                                                                                ",{}]],"21":[["                                                                                ",{}]],"22":[["                                                                                ",{}]],"23":[["                                                                                ",{}]]},"cursor":{"x":0,"y":5}}],[0.000247,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],["                                                                ",{}]]},"cursor":{"x":17}}],[3.192878,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" m                                                              ",{}]]},"cursor":{"x":18}}],[0.119847,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" ma                                                             ",{}]]},"cursor":{"x":19}}],[0.104369,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man                                                            ",{}]]},"cursor":{"x":20}}],[0.112095,{"cursor":{"x":21}}],[3.833612,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man s                                                          ",{}]]},"cursor":{"x":22}}],[0.160002,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man sy                                                         ",{}]]},"cursor":{"x":23}}],[0.048337,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man sys                                                        ",{}]]},"cursor":{"x":24}}],[0.215754,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man syst                                                       ",{}]]},"cursor":{"x":25}}],[0.120439,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man syste                                                      ",{}]]},"cursor":{"x":26}}],[0.159682,{"lines":{"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man system                                                     ",{}]]},"cursor":{"x":27}}],[0.906999,{"cursor":{"x":0,"y":6}}],[0.061806,{"lines":{"0":[["                                                                                ",{}]],"1":[["                                                                                ",{}]],"2":[["                                                                                ",{}]],"3":[["                                                                                ",{}]],"4":[["                                                                                ",{}]],"5":[["                                                                                ",{}]]}}],[0.046163,{"lines":{"6":[["SYSTEM(3)                  Linux Programmer's Manual                 SYSTEM(3)  ",{}]]},"cursor":{"x":78}}],[0.0027,{"lines":{"0":[["SYSTEM(3)                  Linux Programmer's Manual                 SYSTEM(3)  ",{}]],"2":[["NAME",{"bold":true}],["                                                                            ",{}]],"3":[["       system - execute a shell command                                         ",{}]],"5":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"6":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdlib.h>",{"bold":true}],["                                                      ",{}]],"8":[["       ",{}],["int",{"bold":true}],[" ",{}],["system(const",{"bold":true}],[" ",{}],["char",{"bold":true}],[" ",{}],["*",{"bold":true}],["command",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"10":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"11":[["       ",{}],["system",{"bold":true}],["()  executes a command specified in ",{}],["command",{"underline":true}],[" by calling ",{}],["/bin/sh",{"bold":true}],[" ",{}],["-c",{"bold":true}],["  ",{}]],"12":[["       ",{}],["command",{"underline":true}],[", and returns after the command has been completed.  During exe‐  ",{}]],"13":[["       cution  of the command, ",{}],["SIGCHLD",{"bold":true}],[" will be blocked, and ",{}],["SIGINT",{"bold":true}],[" and ",{}],["SIGQUIT",{"bold":true}],["  ",{}]],"14":[["       will be ignored.                                                         ",{}]],"16":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"17":[["       The value returned is -1 on  error  (e.g.,  ",{}],["fork",{"bold":true}],["(2)  failed),  and  the  ",{}]],"18":[["       return  status  of the command otherwise.  This latter return status is  ",{}]],"19":[["       in the format specified in ",{}],["wait",{"bold":true}],["(2).  Thus, the exit code of the command  ",{}]],"20":[["       will  be  ",{}],["WEXITSTATUS(status)",{"underline":true}],[".   In case ",{}],["/bin/sh",{"underline":true}],[" could not be executed,  ",{}]],"21":[["       the exit status will be that of a command that does ",{}],["exit(127)",{"underline":true}],[".           ",{}]],"23":[[" Manual page system(3) line 1 (press h for help or q to quit)",{"inverse":true}],["                   ",{}]]},"cursor":{"x":61,"y":23}}],[5.601887,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" uname -a                                                       ",{}]],"1":[["Linux leon-vb 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i",{}]],"2":[["686 i686 GNU/Linux                                                              ",{}]],"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man calloc                                                     ",{}]],"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man malloc                                                     ",{}]],"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man system                                                     ",{}]],"6":[["                                                                                ",{}]],"8":[["                                                                                ",{}]],"10":[["                                                                                ",{}]],"11":[["                                                                                ",{}]],"12":[["                                                                                ",{}]],"13":[["                                                                                ",{}]],"14":[["                                                                                ",{}]],"16":[["                                                                                ",{}]],"17":[["                                                                                ",{}]],"18":[["                                                                                ",{}]],"19":[["                                                                                ",{}]],"20":[["                                                                                ",{}]],"21":[["                                                                                ",{}]],"23":[["                                                                                ",{}]]},"cursor":{"x":0,"y":6}}],[0.00063,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],["                                                                ",{}]]},"cursor":{"x":17}}],[0.863162,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" m                                                              ",{}]]},"cursor":{"x":18}}],[0.09611,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" ma                                                             ",{}]]},"cursor":{"x":19}}],[0.10482,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man                                                            ",{}]]},"cursor":{"x":20}}],[0.135335,{"cursor":{"x":21}}],[0.167964,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man g                                                          ",{}]]},"cursor":{"x":22}}],[0.096126,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man ge                                                         ",{}]]},"cursor":{"x":23}}],[0.160436,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man get                                                        ",{}]]},"cursor":{"x":24}}],[0.375969,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man getc                                                       ",{}]]},"cursor":{"x":25}}],[0.144513,{"lines":{"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man getch                                                      ",{}]]},"cursor":{"x":26}}],[0.369896,{"cursor":{"x":0,"y":7}}],[0.034037,{"lines":{"7":[["No manual entry for getch                                                       ",{}]]},"cursor":{"x":25}}],[0.00069,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],["                                                                ",{}]]},"cursor":{"x":17,"y":8}}],[1.788353,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" m                                                              ",{}]]},"cursor":{"x":18}}],[0.07256899999999999,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" ma                                                             ",{}]]},"cursor":{"x":19}}],[0.135326,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man                                                            ",{}]]},"cursor":{"x":20}}],[0.135742,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" mang                                                           ",{}]]},"cursor":{"x":21}}],[0.08058800000000001,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" mange                                                          ",{}]]},"cursor":{"x":22}}],[0.151948,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" manget                                                         ",{}]]},"cursor":{"x":23}}],[0.440566,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" mange                                                          ",{}]]},"cursor":{"x":22}}],[0.167725,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" mang                                                           ",{}]]},"cursor":{"x":21}}],[0.160372,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man                                                            ",{}]]},"cursor":{"x":20}}],[0.119872,{"cursor":{"x":21}}],[0.295703,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man g                                                          ",{}]]},"cursor":{"x":22}}],[0.104661,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man ge                                                         ",{}]]},"cursor":{"x":23}}],[0.15132,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man get                                                        ",{}]]},"cursor":{"x":24}}],[0.376729,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man getc                                                       ",{}]]},"cursor":{"x":25}}],[0.151815,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man getch                                                      ",{}]]},"cursor":{"x":26}}],[0.104346,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man getcha                                                     ",{}]]},"cursor":{"x":27}}],[0.135443,{"lines":{"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man getchar                                                    ",{}]]},"cursor":{"x":28}}],[0.468172,{"cursor":{"x":0,"y":9}}],[0.04225,{"lines":{"0":[["                                                                                ",{}]],"1":[["                                                                                ",{}]],"2":[["                                                                                ",{}]],"3":[["                                                                                ",{}]],"4":[["                                                                                ",{}]],"5":[["                                                                                ",{}]],"6":[["                                                                                ",{}]],"7":[["                                                                                ",{}]],"8":[["                                                                                ",{}]]}}],[0.043448,{"lines":{"9":[["GETS(3)                    Linux Programmer's Manual                   GETS(3)  ",{}]]},"cursor":{"x":78}}],[0.004319,{"lines":{"0":[["GETS(3)                    Linux Programmer's Manual                   GETS(3)  ",{}]],"2":[["NAME",{"bold":true}],["                                                                            ",{}]],"3":[["       fgetc,  fgets,  getc,  getchar,  gets, ungetc - input of characters and  ",{}]],"4":[["       strings                                                                  ",{}]],"6":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"7":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdio.h>",{"bold":true}],["                                                       ",{}]],"9":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"11":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"13":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"15":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"17":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"19":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"21":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"22":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"23":[[" Manual page getchar(3) line 1 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]},"cursor":{"x":62,"y":23}}],[1.339574,{"lines":{"0":[["                                                                                ",{}]],"1":[["NAME",{"bold":true}],["                                                                            ",{}]],"2":[["       fgetc,  fgets,  getc,  getchar,  gets, ungetc - input of characters and  ",{}]],"3":[["       strings                                                                  ",{}]],"4":[["                                                                                ",{}]],"5":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"6":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdio.h>",{"bold":true}],["                                                       ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"13":[["                                                                                ",{}]],"14":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"15":[["                                                                                ",{}]],"16":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"17":[["                                                                                ",{}]],"18":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"19":[["                                                                                ",{}]],"20":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"21":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"22":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"23":[[" Manual page getchar(3) line 2 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.500035,{"lines":{"0":[["NAME",{"bold":true}],["                                                                            ",{}]],"1":[["       fgetc,  fgets,  getc,  getchar,  gets, ungetc - input of characters and  ",{}]],"2":[["       strings                                                                  ",{}]],"3":[["                                                                                ",{}]],"4":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"5":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdio.h>",{"bold":true}],["                                                       ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"12":[["                                                                                ",{}]],"13":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"14":[["                                                                                ",{}]],"15":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"16":[["                                                                                ",{}]],"17":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"18":[["                                                                                ",{}]],"19":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"20":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"21":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 5 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030062,{"lines":{"0":[["       fgetc,  fgets,  getc,  getchar,  gets, ungetc - input of characters and  ",{}]],"1":[["       strings                                                                  ",{}]],"2":[["                                                                                ",{}]],"3":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"4":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdio.h>",{"bold":true}],["                                                       ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"13":[["                                                                                ",{}]],"14":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"15":[["                                                                                ",{}]],"16":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"17":[["                                                                                ",{}]],"18":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"19":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"20":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"21":[["                                                                                ",{}]],"22":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"23":[[" Manual page getchar(3) line 6 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030081,{"lines":{"0":[["       strings                                                                  ",{}]],"1":[["                                                                                ",{}]],"2":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"3":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdio.h>",{"bold":true}],["                                                       ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"12":[["                                                                                ",{}]],"13":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"14":[["                                                                                ",{}]],"15":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"16":[["                                                                                ",{}]],"17":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"18":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"19":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"20":[["                                                                                ",{}]],"21":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"22":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"23":[[" Manual page getchar(3) line 7 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030346,{"lines":{"0":[["                                                                                ",{}]],"1":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"2":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdio.h>",{"bold":true}],["                                                       ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"13":[["                                                                                ",{}]],"14":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"15":[["                                                                                ",{}]],"16":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"17":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"18":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"19":[["                                                                                ",{}]],"20":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"21":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 8 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.031375,{"lines":{"0":[["SYNOPSIS",{"bold":true}],["                                                                        ",{}]],"1":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdio.h>",{"bold":true}],["                                                       ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"12":[["                                                                                ",{}]],"13":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"14":[["                                                                                ",{}]],"15":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"16":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"17":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"18":[["                                                                                ",{}]],"19":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"20":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"21":[["                                                                                ",{}]],"22":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"23":[[" Manual page getchar(3) line 9 (press h for help or q to quit)",{"inverse":true}],["                  ",{}]]}}],[0.030561,{"lines":{"0":[["       ",{}],["#include",{"bold":true}],[" ",{}],["<stdio.h>",{"bold":true}],["                                                       ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"13":[["                                                                                ",{}]],"14":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"15":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"16":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"17":[["                                                                                ",{}]],"18":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"19":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"20":[["                                                                                ",{}]],"21":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 10 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]},"cursor":{"x":63}}],[0.030269,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"12":[["                                                                                ",{}]],"13":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"14":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"15":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"16":[["                                                                                ",{}]],"17":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"18":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"19":[["                                                                                ",{}]],"20":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"21":[["                                                                                ",{}]],"22":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"23":[[" Manual page getchar(3) line 11 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.03051,{"lines":{"0":[["       ",{}],["int",{"bold":true}],[" ",{}],["fgetc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                 ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"11":[["                                                                                ",{}]],"12":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"13":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"14":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"15":[["                                                                                ",{}]],"16":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"17":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"18":[["                                                                                ",{}]],"19":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"20":[["                                                                                ",{}]],"21":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"22":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"23":[[" Manual page getchar(3) line 12 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030476,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"10":[["                                                                                ",{}]],"11":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"12":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"13":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"14":[["                                                                                ",{}]],"15":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"16":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"17":[["                                                                                ",{}]],"18":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"19":[["                                                                                ",{}]],"20":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"21":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"22":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"23":[[" Manual page getchar(3) line 13 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.031018,{"lines":{"0":[["       ",{}],["char",{"bold":true}],[" ",{}],["*fgets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[",",{"bold":true}],[" ",{}],["int",{"bold":true}],[" ",{}],["size",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                            ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"9":[["                                                                                ",{}]],"10":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"11":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"12":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"13":[["                                                                                ",{}]],"14":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"15":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"16":[["                                                                                ",{}]],"17":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"18":[["                                                                                ",{}]],"19":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"20":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"21":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 14 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030485,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"8":[["                                                                                ",{}]],"9":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"10":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"11":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"12":[["                                                                                ",{}]],"13":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"14":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"15":[["                                                                                ",{}]],"16":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"17":[["                                                                                ",{}]],"18":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"19":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"20":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"21":[["                                                                                ",{}]],"22":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"23":[[" Manual page getchar(3) line 15 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030349,{"lines":{"0":[["       ",{}],["int",{"bold":true}],[" ",{}],["getc(FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                                  ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"7":[["                                                                                ",{}]],"8":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"9":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"10":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"13":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"14":[["                                                                                ",{}]],"15":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"16":[["                                                                                ",{}]],"17":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"18":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"19":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"20":[["                                                                                ",{}]],"21":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"22":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"23":[[" Manual page getchar(3) line 16 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.029736,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"6":[["                                                                                ",{}]],"7":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"8":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"9":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"12":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"13":[["                                                                                ",{}]],"14":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"15":[["                                                                                ",{}]],"16":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"17":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"18":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"19":[["                                                                                ",{}]],"20":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"21":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"22":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"23":[[" Manual page getchar(3) line 17 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030742,{"lines":{"0":[["       ",{}],["int",{"bold":true}],[" ",{}],["getchar(void);",{"bold":true}],["                                                       ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"5":[["                                                                                ",{}]],"6":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"7":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"8":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"11":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"12":[["                                                                                ",{}]],"13":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"14":[["                                                                                ",{}]],"15":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"16":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"17":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"18":[["                                                                                ",{}]],"19":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"20":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"21":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"22":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"23":[[" Manual page getchar(3) line 18 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.0315,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"4":[["                                                                                ",{}]],"5":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"6":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"7":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"10":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"13":[["                                                                                ",{}]],"14":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"15":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"16":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"17":[["                                                                                ",{}]],"18":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"19":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"20":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"21":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"22":[["       the buffer.                                                              ",{}]],"23":[[" Manual page getchar(3) line 19 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.029994,{"lines":{"0":[["       ",{}],["char",{"bold":true}],[" ",{}],["*gets(char",{"bold":true}],[" ",{}],["*",{"bold":true}],["s",{"underline":true}],[");",{"bold":true}],["                                                     ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"3":[["                                                                                ",{}]],"4":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"5":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"6":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"9":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"12":[["                                                                                ",{}]],"13":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"14":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"15":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"16":[["                                                                                ",{}]],"17":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"18":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"19":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"20":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"21":[["       the buffer.                                                              ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 20 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.0306,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"2":[["                                                                                ",{}]],"3":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"4":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"5":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"8":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"13":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"14":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"15":[["                                                                                ",{}]],"16":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"17":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"18":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"19":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"20":[["       the buffer.                                                              ",{}]],"21":[["                                                                                ",{}]],"22":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"23":[[" Manual page getchar(3) line 21 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.031125,{"lines":{"0":[["       ",{}],["int",{"bold":true}],[" ",{}],["ungetc(int",{"bold":true}],[" ",{}],["c",{"underline":true}],[",",{"bold":true}],[" ",{}],["FILE",{"bold":true}],[" ",{}],["*",{"bold":true}],["stream",{"underline":true}],[");",{"bold":true}],["                                         ",{}]],"1":[["                                                                                ",{}]],"2":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"3":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"4":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"7":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"12":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"13":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"14":[["                                                                                ",{}]],"15":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"16":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"17":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"18":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"19":[["       the buffer.                                                              ",{}]],"20":[["                                                                                ",{}]],"21":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"22":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"23":[[" Manual page getchar(3) line 22 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.029528,{"lines":{"0":[["                                                                                ",{}]],"1":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"2":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"3":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"6":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"11":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"12":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"13":[["                                                                                ",{}]],"14":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"15":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"16":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"17":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"18":[["       the buffer.                                                              ",{}]],"19":[["                                                                                ",{}]],"20":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"21":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"22":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"23":[[" Manual page getchar(3) line 23 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030917,{"lines":{"0":[["DESCRIPTION",{"bold":true}],["                                                                     ",{}]],"1":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"2":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"5":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"10":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"11":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"12":[["                                                                                ",{}]],"13":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"14":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"15":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"16":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"17":[["       the buffer.                                                              ",{}]],"18":[["                                                                                ",{}]],"19":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"20":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"21":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 24 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.031642,{"lines":{"0":[["       ",{}],["fgetc",{"bold":true}],["() reads the next character from  ",{}],["stream",{"underline":true}],["  and  returns  it  as  an  ",{}]],"1":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"4":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"9":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"10":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"13":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"14":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"15":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"16":[["       the buffer.                                                              ",{}]],"17":[["                                                                                ",{}]],"18":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"19":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"20":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"21":[["                                                                                ",{}]],"22":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"23":[[" Manual page getchar(3) line 25 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.029848,{"lines":{"0":[["       ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[", or ",{}],["EOF",{"bold":true}],[" on end of file or error.            ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"3":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"8":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"9":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"12":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"13":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"14":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"15":[["       the buffer.                                                              ",{}]],"16":[["                                                                                ",{}]],"17":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"18":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"19":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"20":[["                                                                                ",{}]],"21":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"22":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"23":[[" Manual page getchar(3) line 26 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030358,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"2":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"7":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"8":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"11":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"12":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"13":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"14":[["       the buffer.                                                              ",{}]],"15":[["                                                                                ",{}]],"16":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"17":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"18":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"19":[["                                                                                ",{}]],"20":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"21":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"22":[["       input stream.                                                            ",{}]],"23":[[" Manual page getchar(3) line 27 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.029728,{"lines":{"0":[["       ",{}],["getc",{"bold":true}],["()  is equivalent to ",{}],["fgetc",{"bold":true}],["() except that it may be implemented as a  ",{}]],"1":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"6":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"7":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"10":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"11":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"12":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"13":[["       the buffer.                                                              ",{}]],"14":[["                                                                                ",{}]],"15":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"16":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"17":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"18":[["                                                                                ",{}]],"19":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"20":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"21":[["       input stream.                                                            ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 28 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030655,{"lines":{"0":[["       macro which evaluates ",{}],["stream",{"underline":true}],[" more than once.                             ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"5":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"6":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"7":[["                                                                                ",{}]],"8":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"9":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"10":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"11":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"12":[["       the buffer.                                                              ",{}]],"13":[["                                                                                ",{}]],"14":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"15":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"16":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"17":[["                                                                                ",{}]],"18":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"19":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"20":[["       input stream.                                                            ",{}]],"21":[["                                                                                ",{}]],"22":[["       For nonlocking counterparts, see ",{}],["unlocked_stdio",{"bold":true}],["(3).                      ",{}]],"23":[[" Manual page getchar(3) line 29 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030477,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"4":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"5":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"6":[["                                                                                ",{}]],"7":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"8":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"9":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"10":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"11":[["       the buffer.                                                              ",{}]],"12":[["                                                                                ",{}]],"13":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"14":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"15":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"16":[["                                                                                ",{}]],"17":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"18":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"19":[["       input stream.                                                            ",{}]],"20":[["                                                                                ",{}]],"21":[["       For nonlocking counterparts, see ",{}],["unlocked_stdio",{"bold":true}],["(3).                      ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 30 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030492,{"lines":{"0":[["       ",{}],["getchar",{"bold":true}],["() is equivalent to ",{}],["getc(",{"bold":true}],["stdin",{"underline":true}],[")",{"bold":true}],[".                                  ",{}]],"1":[["                                                                                ",{}]],"2":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"3":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"4":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"5":[["                                                                                ",{}]],"6":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"7":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"8":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"9":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"10":[["       the buffer.                                                              ",{}]],"11":[["                                                                                ",{}]],"12":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"13":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"14":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"15":[["                                                                                ",{}]],"16":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"17":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"18":[["       input stream.                                                            ",{}]],"19":[["                                                                                ",{}]],"20":[["       For nonlocking counterparts, see ",{}],["unlocked_stdio",{"bold":true}],["(3).                      ",{}]],"21":[["                                                                                ",{}]],"22":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"23":[[" Manual page getchar(3) line 31 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030423,{"lines":{"0":[["                                                                                ",{}]],"1":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"2":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"3":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"4":[["                                                                                ",{}]],"5":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"6":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"7":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"8":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"9":[["       the buffer.                                                              ",{}]],"10":[["                                                                                ",{}]],"11":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"12":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"13":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"14":[["                                                                                ",{}]],"15":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"16":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"17":[["       input stream.                                                            ",{}]],"18":[["                                                                                ",{}]],"19":[["       For nonlocking counterparts, see ",{}],["unlocked_stdio",{"bold":true}],["(3).                      ",{}]],"20":[["                                                                                ",{}]],"21":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"22":[["       ",{}],["fgetc",{"bold":true}],["(), ",{}],["getc",{"bold":true}],["() and ",{}],["getchar",{"bold":true}],["() return the character read as an  ",{}],["unsigned",{"underline":true}],["  ",{}]],"23":[[" Manual page getchar(3) line 32 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.030244,{"lines":{"0":[["       ",{}],["gets",{"bold":true}],["() reads a line from ",{}],["stdin",{"underline":true}],[" into the buffer pointed to  by  ",{}],["s",{"underline":true}],["  until  ",{}]],"1":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"2":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"3":[["                                                                                ",{}]],"4":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"5":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"6":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"7":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"8":[["       the buffer.                                                              ",{}]],"9":[["                                                                                ",{}]],"10":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"11":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"12":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"13":[["                                                                                ",{}]],"14":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"15":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"16":[["       input stream.                                                            ",{}]],"17":[["                                                                                ",{}]],"18":[["       For nonlocking counterparts, see ",{}],["unlocked_stdio",{"bold":true}],["(3).                      ",{}]],"19":[["                                                                                ",{}]],"20":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"21":[["       ",{}],["fgetc",{"bold":true}],["(), ",{}],["getc",{"bold":true}],["() and ",{}],["getchar",{"bold":true}],["() return the character read as an  ",{}],["unsigned",{"underline":true}],["  ",{}]],"22":[["       ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[" or ",{}],["EOF",{"bold":true}],[" on end of file or error.                      ",{}]],"23":[[" Manual page getchar(3) line 33 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.03005,{"lines":{"0":[["       either a terminating newline or ",{}],["EOF",{"bold":true}],[", which it replaces with a null byte  ",{}]],"1":[["       ('\\0').  No check for buffer overrun is performed (see BUGS below).      ",{}]],"2":[["                                                                                ",{}]],"3":[["       ",{}],["fgets",{"bold":true}],["() reads in at most one less than ",{}],["size",{"underline":true}],[" characters from ",{}],["stream",{"underline":true}],["  and  ",{}]],"4":[["       stores  them  into  the buffer pointed to by ",{}],["s",{"underline":true}],[".  Reading stops after an  ",{}]],"5":[["       ",{}],["EOF",{"bold":true}],[" or a newline.  If a newline is read, it is stored into the  buffer.  ",{}]],"6":[["       A  terminating  null  byte ('\\0') is stored after the last character in  ",{}]],"7":[["       the buffer.                                                              ",{}]],"8":[["                                                                                ",{}]],"9":[["       ",{}],["ungetc",{"bold":true}],["() pushes ",{}],["c",{"underline":true}],[" back to ",{}],["stream",{"underline":true}],[", cast to ",{}],["unsigned",{"underline":true}],[" ",{}],["char",{"underline":true}],[",  where  it  is  ",{}]],"10":[["       available  for subsequent read operations.  Pushed-back characters will  ",{}]],"11":[["       be returned in reverse order; only one pushback is guaranteed.           ",{}]],"12":[["                                                                                ",{}]],"13":[["       Calls to the functions described here can be mixed with each other  and  ",{}]],"14":[["       with calls to other input functions from the ",{}],["stdio",{"underline":true}],[" library for the same  ",{}]],"15":[["       input stream.                                                            ",{}]],"16":[["                                                                                ",{}]],"17":[["       For nonlocking counterparts, see ",{}],["unlocked_stdio",{"bold":true}],["(3).                      ",{}]],"18":[["                                                                                ",{}]],"19":[["RETURN",{"bold":true}],[" ",{}],["VALUE",{"bold":true}],["                                                                    ",{}]],"20":[["       ",{}],["fgetc",{"bold":true}],["(), ",{}],["getc",{"bold":true}],["() and ",{}],["getchar",{"bold":true}],["() return the character read as an  ",{}],["unsigned",{"underline":true}],["  ",{}]],"21":[["       ",{}],["char",{"underline":true}],[" cast to an ",{}],["int",{"underline":true}],[" or ",{}],["EOF",{"bold":true}],[" on end of file or error.                      ",{}]],"22":[["                                                                                ",{}]],"23":[[" Manual page getchar(3) line 34 (press h for help or q to quit)",{"inverse":true}],["                 ",{}]]}}],[0.025903,{"lines":{"0":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" uname -a                                                       ",{}]],"1":[["Linux leon-vb 3.8.0-19-generic #30-Ubuntu SMP Wed May 1 16:36:13 UTC 2013 i686 i",{}]],"2":[["686 i686 GNU/Linux                                                              ",{}]],"3":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man calloc                                                     ",{}]],"4":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man malloc                                                     ",{}]],"5":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man system                                                     ",{}]],"6":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man getch                                                      ",{}]],"7":[["No manual entry for getch                                                       ",{}]],"8":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" man getchar                                                    ",{}]],"9":[["                                                                                ",{}]],"10":[["                                                                                ",{}]],"11":[["                                                                                ",{}]],"13":[["                                                                                ",{}]],"14":[["                                                                                ",{}]],"15":[["                                                                                ",{}]],"17":[["                                                                                ",{}]],"19":[["                                                                                ",{}]],"20":[["                                                                                ",{}]],"21":[["                                                                                ",{}]],"23":[["                                                                                ",{}]]},"cursor":{"x":0,"y":9}}],[0.000263,{"lines":{"9":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],["                                                                ",{}]]},"cursor":{"x":17}}],[1.959912,{"lines":{"9":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" e                                                              ",{}]]},"cursor":{"x":18}}],[0.152019,{"lines":{"9":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" ex                                                             ",{}]]},"cursor":{"x":19}}],[0.199417,{"lines":{"9":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" exi                                                            ",{}]]},"cursor":{"x":20}}],[0.120464,{"lines":{"9":[["leon@leon-vb",{"fg":2,"bold":true}],[" ~ $",{"fg":4,"bold":true}],[" exit                                                           ",{}]]},"cursor":{"x":21}}],[0.168268,{"lines":{"10":[["exit                                                                            ",{}]]},"cursor":{"x":0,"y":11}}]]