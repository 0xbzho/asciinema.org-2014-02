{"ID":7829,"Author":{"Name":"vinipsmaker","ID":0,"FullName":"","Gravatar":"af5ecb0a0194dc031a80074bbf9888b7"},"Title":"Sessão de depuração no gdb","Description":"\u003cdiv class=\"content\"\u003e\u003cp\u003e\u003ca href=\"https://vinipsmaker.wordpress.com/2013/12/20/meu-erro-favorito-de-cc-falha-de-segmentacao/\"\u003ehttps://vinipsmaker.wordpress.com/2013/12/20/meu-erro-favorito-de-cc-falha-de-segmentacao/\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eCódigo-fonte do programa de teste: \u003ca href=\"https://gist.github.com/vinipsmaker/8090952\"\u003ehttps://gist.github.com/vinipsmaker/8090952\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eA epifania ocorre no final da sessão, quando você nota que a variável \u003ccode\u003ecliente\u003c/code\u003e não é completamente inicializada, deixando o atributo \u003ccode\u003ecompras\u003c/code\u003e apontar para lixo de memória. Através do gdb, você fica sabendo exatamente que pedaço do código quebrou o programa inteiro deixando as variáveis em estados inconsistentes.\u003c/p\u003e\n\n\u003cp\u003eCódigos em produção usando C++ não são assim tão frágeis. O erro poderia ter sido evitado usando \u003cem\u003eC++ moderno\u003c/em\u003e, mas a intenção foi demonstrar como encontrar erros de falha de segmentação usando o gdb pode ser fácil.\u003c/p\u003e\n\u003c/div\u003e","Time":"2014-02-23T17:51:44Z","Tags":["Linux","zsh","xterm"]}